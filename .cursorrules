# Data Tune Solutions - Business Context

## Company Information
- **Name**: Data Tune Solutions
- **Industry**: Data Engineering & Analytics Consulting
- **Primary Services**: Data pipeline development, data visualization, business intelligence solutions
- **Tech Stack**: 
  - **Primary**: Azure Data Factory, Power BI, SQL Server, Microsoft Fabric
  - **Secondary**: BigQuery, Snowflake
  - **Languages**: SQL (T-SQL, DAX, M/Power Query), Python (learning/future)
- **Team Size**: Solo consultant

## Business Philosophy & Approach
- **Decision-Making Framework**: 
  - Prioritize data quality and pipeline reliability
  - Choose managed services over custom solutions when possible
  - Focus on maintainable, well-documented code
  - Separate dev and production environments for Power BI
  
- **Code Standards**: 
  - Clear, descriptive naming conventions
  - SQL: Use CTEs over nested subqueries for readability
  - Comment complex transformations and business logic
  - Modular approach - create reusable components
  
- **Documentation Requirements**: 
  - Document data sources, transformations, and business logic
  - Include connection requirements and dependencies
  - Maintain data dictionaries for key datasets
  - Track client-specific requirements
  
- **Version Control Philosophy**: 
  - Version control SQL scripts, DAX measures, M queries
  - Do NOT commit .pbix files (use dev/prod pattern instead)
  - Do NOT commit actual data files (only schema/sample data if needed)
  - Keep client credentials in .env files (never committed)

## Common Project Patterns
- **Data Pipeline Projects**: Extract → Transform → Load patterns using Azure Data Factory or SQL stored procedures
- **Power BI Development**: Development .pbix → Testing → Production deployment
- **Cross-Platform Integration**: Connecting Azure ecosystem to BigQuery/Snowflake sources
- **Data Quality**: Implementing validation checks and monitoring

## Communication Preferences
- **Code Style**: Clear and well-commented, prefer readability over brevity
- **Explanation Level**: Full explanations during planning/review, minimal during execution
- **Approval Required**: Always get approval before starting work (user is learning)
- **Examples**: Prefer concrete examples with sample data/schemas

### Communication Strategy (Balanced for Beginners)
- **Before Execution**: Full warnings, complete plans with self-critique, wait for approval
- **During Execution**: Silent (no progress updates unless blocked or error occurs)
- **After Execution**: Comprehensive review with all changes, token usage, and important notes

## Data Engineering Best Practices
- Always consider data refresh schedules and dependencies
- Plan for incremental loads when possible
- Include error handling and logging in pipelines
- Document data lineage and transformations
- Consider performance implications (partitioning, indexing)
- Separate credentials from code using environment variables or Azure Key Vault

## Client Project Structure
- Each client project is a separate Git repository
- Maintain dev/test/prod separation
- Include README with setup instructions and dependencies
- Document connection strings format (without actual credentials)
- Include any custom DAX measures or M queries as separate files

## Current Focus Areas
- Building reusable SQL and DAX pattern library
- Exploring Python for data pipeline automation
- Standardizing project setup and documentation
- Establishing efficient dev-to-production workflows

## Claude AI Workflow Rules

### Task Management Process
1. **Plan First**: Before starting any task, think through the problem, read relevant files, and create a plan in `tasks/todo.md`
2. **Create Todo List**: The plan must include a checklist of specific todo items
3. **Self-Critique** (MANDATORY): Review own plan for cost efficiency, risks, missing context, and scope issues
4. **Get Approval**: Present the plan AND self-critique, wait for verification before beginning work
5. **Execute Silently**: Work through todo items without intermediate updates unless blocked
6. **Document Results**: Add a review section to `tasks/todo.md` with summary, files changed, and token usage

### Code Change Principles
- **Simplicity First**: Make every task and code change as simple as possible
- **Minimal Impact**: Changes should affect as little code as possible - only what's necessary
- **No Shortcuts**: Never use temporary fixes or lazy solutions
- **Root Cause Focus**: If there's a bug, find and fix the root cause completely
- **Senior-Level Quality**: Approach every problem with thoroughness and professionalism
- **Bug Prevention**: Goal is to avoid introducing any new bugs through careful, simple changes

### Problem-Solving Approach
- Break complex problems into simple, discrete steps
- Each change should be focused and targeted
- Prefer incremental improvements over large refactors
- Think like a senior developer: thorough, careful, and complete
- Never skip proper investigation or cut corners

## Cost Optimization Preferences

### Efficient API Usage
- **Batch Operations**: Prefer completing full tasks in one go over multiple incremental asks
- **Trust the Plan**: Once a plan is approved, execute it fully without intermediate check-ins
- **Assume Standards**: Follow established patterns and conventions without asking for confirmation
- **Silent Execution**: No progress updates during execution; report comprehensively at completion
- **Reference First**: Always check the pattern library and existing documentation before creating new solutions
- **Complete Execution**: After approval, work through all todo items and only report back when done or if blockers arise
- **Consolidate Changes**: Group related file changes together rather than asking about each one separately
- **Leverage Documentation**: Use the comprehensive docs in data-tune-core/ as the source of truth to avoid redundant questions

### Proactive Cost Warnings
- **Always warn** before starting if: reading 5+ files, estimated >3,000 tokens, missing context, mixed tasks, large files without line numbers
- **Include estimates** in warnings: "This will cost ~X,XXX tokens"
- **Suggest optimizations**: "Could be ~X,XXX tokens if you provide [specific context]"
- **Wait for confirmation** after warning: user can proceed, optimize, or revise

### Self-Critique Requirements
- **Mandatory for every plan** - no exceptions
- **Focus areas**: Cost efficiency, approach validation, missing context, scope check
- **Format**: Estimate tokens, list issues, suggest optimizations, provide recommendation
- **Depth varies**: Simple tasks = brief critique, complex tasks = detailed critique
- **Critical issues**: If plan will definitely fail, revise before presenting
- **Warnings**: If plan might be inefficient, present both options to user

### ClaudeCode-First Strategy (Rate Limit Prevention)

**The Problem We Solved:**
- Claude API file operations = API calls = rate limiting + token costs
- ClaudeCode file operations = local execution = FREE + no limits

**ClaudeCode-First Approach:**
When tasks involve file operations, default to this workflow:
1. **Claude designs** the structure/templates (API - necessary)
2. **User implements** with ClaudeCode (FREE - file creation/editing)
3. **Claude reviews** the result (API - quality check)

**Result:** 80-95% fewer API calls, zero rate limiting, massive token savings

### When to Use ClaudeCode (Prefer This)

**Always use ClaudeCode for:**
- Creating multiple new files (5+ files)
- Batch editing existing files
- Copying and customizing templates
- Moving/renaming files or folders
- Bulk find-and-replace operations
- Repetitive structural changes
- Formatting and style fixes
- Adding boilerplate code to multiple files

**Why:** These are mechanical operations that don't require AI reasoning. Using Claude API here wastes tokens and hits rate limits.

### When to Use Claude API (Necessary)

**Use Claude API only for:**
- Complex problem solving and architecture decisions
- Writing business logic and algorithms
- Understanding/explaining existing code
- Debugging and root cause analysis
- Design patterns and best practices
- Code review and optimization suggestions
- Generating complex queries or transformations

**Why:** These require AI reasoning and can't be done mechanically.

### Execution Examples

**❌ BAD (API-Heavy, Rate Limit Risk):**
```
User: "Create 6 client folders with README files"
Claude: *creates all 6 folders and 6 files via API* → 12+ API calls, rate limit risk
```

**✅ GOOD (ClaudeCode-First):**
```
User: "Create 6 client folders with README files"
Claude: "Here's the folder structure and README template. Run these commands:
         mkdir client-a client-b client-c ...
         Then copy this template into each README.md"
User: *executes locally via ClaudeCode* → 0 API file operations
Claude: "Let me verify the structure looks correct" → 1 API call
```

**❌ BAD:**
```
User: "Update all 10 config files with the new API endpoint"
Claude: *edits each file one by one* → 10+ API calls
```

**✅ GOOD:**
```
User: "Update all 10 config files with the new API endpoint"
Claude: "Run this find-and-replace in ClaudeCode:
         Find: 'old-api.example.com'
         Replace: 'new-api.example.com'
         Files: *.config.json"
User: *executes bulk replace* → 0 API calls
```

**❌ BAD:**
```
User: "Set up the standard project structure for new client"
Claude: *creates 15 files/folders via API* → 15+ API calls, likely rate limited
```

**✅ GOOD:**
```
User: "Set up the standard project structure for new client"
Claude: "Copy the template folder:
         cp -r _core/templates/new-project clients/new-client
         Then update these 3 values in the config..."
User: *copies template, makes small edits* → 0 API calls for structure
Claude: *reviews and suggests any customizations* → 1-2 API calls
```

### Quick Decision Guide

| Task Type | Use | Why |
|-----------|-----|-----|
| Create 1-2 files | Claude API | Low overhead, faster |
| Create 3+ files | ClaudeCode | Avoid rate limits |
| Simple find/replace | ClaudeCode | Mechanical operation |
| Complex refactoring | Claude API | Requires reasoning |
| Copy/move files | ClaudeCode | Always free locally |
| Write new logic | Claude API | AI reasoning needed |
| Format/lint fixes | ClaudeCode | Mechanical operation |
| Debug complex issue | Claude API | Analysis required |
